### 常用库文件

```
momentjs ,bootMDN
```

### 1.HTML语义化

### 2.HTML5新标签

```css
3.标准盒模型
border-box:content-box;
// 长度= width+padding+border 
4.IE盒模型 border-box
// 长度 = style中设置的width数值
```

### 4.css选择器权重

！important > 行内式 > #id > .class > 标签或伪元素 > * >继承 

### 5.generator函数:

``` js
function* generator(i) {
  yield i;
  yield i + 10;
}
generator(i).next()//用next（）得到结果
// for-of可循环结果
```



generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，

### 6.介绍防抖节流原理、区别以及应用，并用JavaScript进行实现

​	1.防抖：（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。

​	2.函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。

### 7.使用delete删除数组元素，其长度会改变吗？

​	所以我们使用`delete`操作符删除一个数组元素时，相当于移除了数组中的一个属性，被删除的元素已经不再属于该数组。但是这种改变并不会影响数组的`length`属性。

### 8.JS是如何执行宏任务和微任务？

1、先初始化所有同步代码       

2、在准备执行每一个宏任务之前，都要先将微任务一个一个的执行完

### 9.let与const	

​	1.`const命令`声明常量后必须立马赋值，不允许重复声明

​	2.未定义就使用会报错：`const命令`和`let命令`不存在变量提升

​	3.暂时性死区：在代码块内使用`const命令`和`let命令`声明变量之前，该变量都不可用

### 10.Node 中 exports 与 module.exports 有什么联系

​	答：exports 是module.exports 的引用

### 11.浏览器页面渲染流程

- （1）解析HTML文件，构建 `DOM Tree`
- （2）解析CSS，构建 `CSSOM Tree`(CSS规则树)
- （3）将 DOM Tree 和 CSSOM Tree合并，构建`Render tree(渲染树)`
- （4）`reflow`(重排，回流)：当`Render Tree`中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。
- （5）`repaint`(重绘)：当页面中元素样式的改变并不影响它在文档流中的位置时（例如：`color`、`background-color`、`visibility`等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

> 理论上，每一次的dom更改或者css几何属性更改，都会引起一次浏览器的重排/重绘过程，而如果是css的非几何属性更改，则只会引起重绘过程。所以说`重排一定会引起重绘，而重绘不一定会引起重排`。

##### 	11.1 会引起reflow的操作

- 页面首次渲染

- 浏览器窗口大小发生改变

- 元素尺寸或位置发生改变

- 元素内容变化（文字数量或图片大小等等）

- 元素字体大小变化

- 添加或者删除**可见**的`DOM`元素

- 激活`CSS`伪类（例如：`:hover`）

- 读写`offset/scroll/client`等属性时会触发回流,调用`window.getComputedStyle`会触发回流

  ##### 	11.2 一些会引起reflow的属性和方法

  一些常用且会导致回流的属性和方法：

  - `clientWidth`、`clientHeight`、`clientTop`、`clientLeft`
  - `offsetWidth`、`offsetHeight`、`offsetTop`、`offsetLeft`
  - `scrollWidth`、`scrollHeight`、`scrollTop`、`scrollLeft`
  - `scrollIntoView()`、`scrollIntoViewIfNeeded()`
  - `getComputedStyle()`
  - `getBoundingClientRect()`
  - `scrollTo()`

JS脚本会阻塞Render tree的构建，即阻塞了页面的渲染。

### 12.css加载会造成阻塞吗？

1. css加载不会阻塞DOM树的解析

2. css加载会阻塞DOM树的渲染

3. css加载会阻塞后面js语句的执行

   ##### 基于原理上的解释：cssTree和DOMTree是并行的，但是Render Tree必须等到二者都就绪才能解析

    所以，为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度，比如可以使用以下几种方法:

   1. 使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)
   2. 对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)
   3. 合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)
   4. 减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)

   

### 13. flex布局

##### 1.父容器中设置：

​	1. 设置子容器沿主轴排列：**justify-content**

​		<1>. **flex-start**：起始端对齐

​		<2>. **flex-end**：末尾段对齐

​		<3>. **center**：居中对齐

​		<4>. **space-around**：子容器沿主轴均匀分布，位于首尾两端的子容器到父容器的距离是子容器间距的一半。

​		<5>. **space-between**：子容器沿主轴均匀分布，位于首尾两端的子容器与父容器相切。

![flex1](https://lc-gold-cdn.xitu.io/be5b7f0e022a8da60ed8.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

​	2. 设置子容器如何沿交叉轴排列：**align-items**

​		<1>. **flex-start**：起始端对齐

​		<2>. **flex-end**：末尾段对齐

​		<3>. **center**：居中对齐

​		<4>. ****baseline**：基线对齐，这里的 `baseline` 默认是指首行文字，即 `first baseline`，所有子容器向基线对齐，交叉轴起点到元素基线距离最大的子容器将会与交叉轴起始端相切以确定基线。

​		<5>. **stretch**：子容器沿交叉轴方向的尺寸拉伸至与父容器一致。

![flex2](https://lc-gold-cdn.xitu.io/e7e6aa079f5333828c58.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

​	3.设置换行方式：**flex-wrap**

​		 flex-wrap : nowrap(不换行) || wrap(换行) || wrap-reverse(反向换行)

​	4.多行沿交叉轴对齐：**align-content**

  当子容器多行排列时，设置行与行之间的对齐方式。

##### 2.子容器中设置：

1. 在主轴上如何伸缩：**flex**

![](https://lc-gold-cdn.xitu.io/78e9030183f686e0b6ed.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

2. 单独设置子容器如何沿交叉轴排列：**align-self**

​	此属性的可选值与父容器 `align-items` 属性完全一致，如果两者同时设置则以子容器的 `align-self` 属性为准。

![](https://lc-gold-cdn.xitu.io/1d09fe5bb413a6dfa5dd.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

3. 设置基准大小：**flex-basis**

4. 设置扩展比例：**flex-grow**

   子容器弹性伸展的比例。剩余空间按比例( 例如1:2)分配给子容器。

5. 设置收缩比例：**flex-shrink**

   子容器弹性收缩的比例。超出的部分按比例( 例如1:2)从给子容器中减去。

   ![](https://lc-gold-cdn.xitu.io/38596937d4f86beeac0b.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

![](https://lc-gold-cdn.xitu.io/d278e36c13b9643ff481.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

6. 设置排列顺序：**order**

  默认值为 0，可以为负值，数值越小排列越靠前。

### 14.Grid布局

​        在元素上声明 `display：grid` 或 `display：inline-grid` 来创建一个网格容器

​        网格轨道：`grid-template-columns(设置列宽)` 和 `grid-template-rows(设置行高)` 属性来定义网格中的行和列

##### 1.grid-template-columns 和grid-template-rows

```css
固定的列宽和行高
.wrapper {
  display: grid;
  /*  声明了三列，宽度分别为 200px 100px 200px */
  grid-template-columns: 200px 100px 200px;
  grid-gap: 5px;
  /*  声明了两行，行高分别为 50px 50px  */
  grid-template-rows: 50px 50px;
  /* 另一种写法 repeat()函数
    该函数接受两个参数，第一个参数是重复的次数，第二个参数是所要重复的值
   grid-template-rows: repeat(2, 50px);
  */
}

```

 **repeat()函数**:

关键字：

​	**1.auto-fill,** 

​	**2.fr,**

​	**3.minmax() 函数**--(给网格元素一个最小和最大的尺寸)，

```js
  grid-template-columns: 1fr 1fr minmax(300px, 2fr);
//eg:`grid-template-columns: 1fr 1fr minmax(300px, 2fr)` 的意思是，第三个列宽最少也是要 300px，但是最大不能大于第一第二列宽的两倍
```

​	**4.auto**: 由浏览器决定长度



### 15.vue 路由 按需 keep-alive

**目的**：为了在index->list->detail三个组件切换时，想达到当detail回退到list组件时是调用缓存(回到之前用户记忆的地方)，而不是重新获取数据

[文章链接]: https://juejin.im/post/6844903846901186574	"文章链接"



​	`keep-alive`是`Vue`提供的一个抽象组件，主要用于保留组件状态或避免重新渲染，用法：包裹需要缓存的组件实例。

![](https://user-gold-cdn.xitu.io/2019/5/19/16acff709701145a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

```html
<keep-alive>     
    <!-- 需要缓存的视图组件 -->  
    <router-view v-if="$route.meta.keepAlive">   </router-view> </keep-alive>  
        
    <!-- 不需要缓存的视图组件 --> 
<router-view v-if="!$route.meta.keepAlive"> 
</router-view>
```

### 16. el-form重置操作原理

**目的** ：点击修改当前行按钮后，解决重置不了input值的bug！

使用`this.$nextTick`，

```js
在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
// 修改数据
vm.msg = 'Hello'
// DOM 还没有更新
Vue.nextTick(function () {
  // DOM 更新了
})
```

过程: 

1. 点击showdialog，执行showdialog函数(purpose：想将当前值显示到input中)

2. 如果没有使用$nextTick函数，那么会执行完showdialog函数后再渲染<el-form-item>表单，此时已将<el-form-item>组件中的`initialValue: ''`值更改为100
3. 因为重置方法在<el-form-item>中，且赋值的是此组件中的`initialValue`，所以想要重置，必须让这里的初始值在showDialog()中的赋值后调用

详细见文件地址：U盘:\Vue视频\晚自习补充

### 17.element自定义组件

在官网F12 复制对应的DOM文件，然后组件化实现功能

### 18.二叉树

满二叉树：每一层都挂满两个节点。(深度为h，那么有2^h-1个结点)

完全二叉树：除了最后一层，之前都是满节点

平很二叉树：

### 19.DFS和BFS

DFS(深度优先遍历): 对每个分支一直往下直到分支结束，然后返回上一层，对上一层的右子树这个分支继续深搜。

BFS(广度优先遍历)：对每一层结点依次遍历，一层遍历完再对下一层进行遍历

### 20.CORS（跨域）

  当资源位于不同**协议**、**子域**或**端口**的站点时，这个请求就是跨域的。

  同源政策可以防止钓鱼网站，增加安全系数。

  1.Web 程序发出跨域请求后，浏览器会**自动**向我们的 HTTP header 添加一个额外的请求头字段：`Origin`

  2.我们可以通过在 HTTP 响应中添加额外的响应头字段 `Access-Control-*` 来表明是否允许跨域请求，其中Access-Control-Allow-Origin这个是必加的。这个头字段的值指定了哪些站点被允许跨域访问资源。

  3.收到服务器返回的 response 后，浏览器中的 CORS 机制会检查 `Access-Control-Allow-Origin` 的值是否等于 request 中 `Origin` 的值。

> CORS 还允许我们添加通配符 `*` 作为允许的外域，这意味着该资源可以被**任意**外域访问，所以要注意这种特殊情况

ps：另一个常见的响应头字段是 `Access-Control-Allow-Methods`。其指明了跨域请求所允许使用的 HTTP 方法。

```js
respose.header(
"Access-Control-Allow-Methods",['post','put','get']
)
```

#### 预检请求

作用：业务中经常有自定义 header，这种自定义类型浏览器无法预测和确保安全性，所以会有个协商的过程，这个协商过程就叫预检

每次实际请求（get,post,put....），都会发送两次请求.

1. 实际请求之前客户端会先使用 [`OPTIONS`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS) 方法发起一个预检请求(包含实际请求的信息,method 、headers附带头部字段),

2. 服务器接收到预检请求后，会返回一个没有 body 的 HTTP 响应，这个响应标记了服务器允许的 HTTP 方法和 HTTP Header 字段

3.  浏览器收到预检响应，并检查是否应允许发送实际请求。

### 21.axios

**它是基于promise的http库，可运行在浏览器端和node.js中**